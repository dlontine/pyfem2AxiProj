#!/usr/bin/env python
import re
import os
import logging
from numpy import array

def ElementType(numnod, material):
    m = material.lower()
    if m == 'planestress':
        if numnod == 8:
            return 'PlaneStressQuad8'
        elif numnod == 3:
            return 'PlaneStressTria3'
        elif numnod == 4:
            return 'PlaneStressQuad4'
    print(m)
    print(numnod)
    raise Exception('UNKNOWN ELEMENT')

def MaterialModel(material):
    model = {}
    for item in dir(material):
        if item.startswith('_'):
            continue
        elif item in ('store', 'type'):
            continue
        if item in ('e', 'nu'):
            model[item.title()] = getattr(material, item)
            continue
        logging.warn('UNKNOWN MATERIAL CONSTANT: {0}'.format(item))
    return {'elastic': model}

def strip_and_lower(key):
    key = ''.join(re.sub(r'[\'\"]', '', key.lower()).split())
    return key

class Properties:

  def __init__ ( self, dictionary = {} ):

    for key in dictionary.keys():
      key = strip_and_lower(key)
      setattr( self, key, dictionary[key] )

  def __str__ ( self ):

    myStr  = ''
    for att in dir( self ):

      #Ignore private members and standard routines
      if att.startswith('__'):
        continue
      if att == 'store':
        continue

      myStr += 'Attribute: ' + att + '\n'
      myStr += str( getattr(self,att) ) + '\n'

    return myStr

  def __iter__ ( self ):

    propsList = []
    for att in dir( self ):

      #Ignore private members and standard routines
      if att.startswith('__'):
        continue

      propsList.append( ( att, getattr(self,att) ) )

    return iter(propsList)

  def store ( self , key , val ):
    key = strip_and_lower(key)
    setattr( self , key , val )

def containsValue( db , val ):

  keys = db.keys()

  for key in keys:

    if type(db[key]) == dict:
      if containsValue(db[key],val):
        return True
    else:
      if db[key] == val:
        return True
  return False

def getType( a ):

  if a == 'true':
    return True
  elif a == 'false':
    return False
  else:
    try:
      return eval(a)
    except:
      return a

def storeValue( db , key , a ):

  if type(a) == list:
    tmp=[]
    for v in a:
      tmp.append(getType(v))
    db.store( key , tmp )
  else:
    db.store( key , getType(a) )

def readItem( l1 , db ):

  if '.' in l1[0]:
    l2 = l1[0].split('.',1)

    if db.has_key(l2[0]):
      if type(db[l2[0]]) == dict:
        child=db[l2[0]]
      else:
        child=Properties()
    else:
      child=Properties()

    l1[0]=l2[1]

    ln = readItem( l1 , child )

    db[l2[0]] = child

    return ln

  else:
    l2 = l1[1].split(';',1)

    if l2[0][0] == '[':
      l3 = l2[0][1:-1].split(',')
      storeValue( db , l1[0] , l3 )
    else:
      storeValue( db , l1[0] , l2[0] )

    return l2[1]

def readBlock( ln , db ):

  while True:

    if ln[0:7] == 'include':
      l1 = ln.split(';',1)
      deepFileParser( l1[0][8:-1] , db )
      ln = l1[1]
      continue

    l1 = ln.split('=',1)

    if len(l1) == 1:
      return ln

    if l1[0][0:2] == '};':
      return ln[2:]

    if l1[0][0:2] == '//':
      ln = l1[1].split(';',1)[1]
      continue

    #if l1[0][0:1] == '#':
    #  ln = l1[1].split(';',1)[1]
    #  continue

    if l1[1][0] == '{':
      child = Properties()
      ln = l1[1][1:]

      ln = readBlock( ln , child )

      db.store( l1[0] , child )

    else:
      ln = readItem( l1 , db )

def fileParser( fileName ):

  db = Properties()

  f = open(fileName)

  f2 = ''

  for line in f:
    if not line.startswith('#'):
      f2 = f2+line

  ln = open(fileName).read().replace('\n','').replace('\t','').replace(' ','').replace('\r','')
  ln = f2.replace('\n','').replace('\t','').replace(' ','').replace('\r','')

  readBlock( ln , db )

  return db

def deepFileParser( fileName , db ):

  ln = open(fileName).read().replace('\n','').replace('\t','').replace(' ','').replace('\r','')

  readBlock( ln , db )

  return db

def ParseInput(filename, output=None):

    filepath = os.path.realpath(filename)
    d = os.path.dirname(filepath)
    props = fileParser(filename)
    data_file = props.input
    if not os.path.isfile(data_file):
        data_file = os.path.join(d, data_file)
    nodtab, eletab, bcs, cfs = parse_data_file(data_file)

    mats = {}
    ebs = {}
    for (i, elem) in enumerate(eletab):
        label, et, nodes = elem[0], elem[1], elem[2:]
        eledef = getattr(props, et)
        mat = getattr(eledef, 'material')
        eletyp = ElementType(len(nodes), mat.type)
        key = (eletyp, mat.type.lower())
        if key not in mats:
            matname = 'Material-{0}'.format(len(mats)+1)
            mats[key] = {'name': matname, 'material': MaterialModel(mat)}
        if key not in ebs:
            blkname = 'ElementBlock-{0}'.format(len(ebs)+1)
            ebs[key] = {'name': blkname,
                        'element': eletyp,
                        'labels': [label],
                        'material': mats[key]['name']}
        else:
            ebs[key]['labels'].append(label)

    if output is not None:
        f, ext = os.path.splitext(output)
        if ext == '.inp':
            to_inp(output, nodtab, eletab, bcs, cfs)
        elif ext == '.py':
            to_py(output, nodtab, eletab, bcs, cfs, ebs, mats)

def open_and_read(filename):
    lines = []
    for line in open(filename, 'r').readlines():
        line = line.split('#', 1)[0]
        line = line.split('//', 1)[0]
        if not line.split():
            continue
        lines.append(line)
    return '\n'.join(lines)

def parse_data_file(filename):

    string = open_and_read(filename)

    # FIND NODES
    match = re.search(r'(?ims)<nodes>(?P<n>.*)?<\/nodes>', string)
    if not match:
        raise ValueError('NO NODES FOUND')
    labels, coords = [], []
    for line in match.group('n').split('\n'):
        for item in line.split(';'):
            item = item.split()
            if not item:
                continue
            labels.append(int(item[0]))
            coords.append([float(x) for x in item[1:]])
    labels = array(labels)
    offset = 1 if labels.min() == 0 else 0
    nmap = dict([(label, label+offset) for label in labels])
    nodtab = [[label+offset]+coords[i] for (i, label) in enumerate(labels)]

    # FIND ELEMENTS
    match = re.search(r'(?ims)<elements>(?P<e>.*)?<\/elements>', string)
    if not match:
        raise ValueError('NO ELEMENTS FOUND')
    eletab = []
    for line in match.group('e').split('\n'):
        for item in line.split(';'):
            item = item.split()
            if not item:
                continue
            label = int(item[0])
            eletyp = strip_and_lower(item[1])
            connect = array([int(x) for x in item[2:]])
            if len(connect) == 8:
                # REORDER FOR PYFEM2
                connect = connect[[0,2,4,6,1,3,5,7]]
            elif len(connect) == 6:
                # REORDER FOR PYFEM2
                connect = connect[[0,2,4,1,3,5]]
            eletab.append([label, eletyp] + [nmap[x] for x in connect])

    # BOUNDARY CONDITIONS
    rx = r'(?ims)<nodeconstraints>(?P<nc>.*)?<\/nodeconstraints>'
    match = re.search(rx, string)
    if match:
        bcs = {}
        for line in match.group('nc').split('\n'):
            for item in line.split(';'):
                if not item.split():
                    continue
                item = item.split('=')
                a, n = re.split(r'[\[\]]', item[0].strip())[:2]
                bcs[(nmap[int(n)], a.upper())] = float(item[1])

    rx = r'(?ims)<externalforces>(?P<cf>.*)?<\/externalforces>'
    match = re.search(rx, string)
    if match:
        cfs = {}
        for line in match.group('cf').split('\n'):
            for item in line.split(';'):
                if not item.split():
                    continue
                item = item.split('=')
                a, n = re.split(r'[\[\]]', item[0].strip())[:2]
                cfs[(nmap[int(n)], a.upper())] = float(item[1])

    return nodtab, eletab, bcs, cfs

def tostr(a):
    rows = ['['+', '.join('{0}'.format(x) for x in row)+'],' for row in a]
    return '[' + '\n          '.join(rows) + ']'

def to_py(output, nodtab, eletab, bcs, cfs, eleblx, materials):
    et = [[e[0]]+e[2:] for e in eletab]
    string = ["from pyfem2 import *",
              "nodtab = {0}".format(tostr(nodtab)),
              "eletab = {0}\n".format(tostr(et)),
              "def RunModel():",
              "    mesh = Mesh(nodtab=nodtab, eletab=eletab)",
              "    V = FiniteElementModel(mesh=mesh)"]
    matmap = {}
    for (key, material) in materials.items():
        kw = 'mat_{0}'.format(len(matmap)+1)
        if key not in matmap:
            matmap[key] = kw
        name = material['name']
        elastic = repr(material['material']['elastic'])
        string.append("    {0} = Material('{1}', elastic={2})".format(
            kw, name, elastic))

    for (key, eb) in eleblx.items():
        name = eb['name']
        labels = ', '.join('{0}'.format(label) for label in eb['labels'])
        string.append("    V.ElementBlock('{0}', ({1}))".format(name, labels))
        string.append("    V.AssignProperties('{0}', {1}, {2})".format(
            name, eb['element'], matmap[key]))

    string.append("    step = V.StaticStep()")
    for key in sorted(bcs.keys()):
        mag = bcs[key]
        n, dof = key
        dof = {'U': 'X', 'V': 'Y'}[dof.upper()]
        string.append("    step.PrescribedBC({0}, {1}, {2})".format(n, dof, mag))

    for key in sorted(cfs.keys()):
        mag = cfs[key]
        n, dof = key
        dof = {'U': 'X', 'V': 'Y'}[dof.upper()]
        string.append("    step.ConcentratedLoad({0}, {1}, {2})".format(n, dof, mag))

    string.append("    step.run()")
    string.append("\nif __name__ == '__main__':\n    RunModel()")

    with open(output, 'w') as fh:
        fh.write('\n'.join(string))

def to_inp(output, nodtab, eletab, bcs, cfs):

    fh = open(output, 'w')
    fh.write('*Node, nset=NAll\n')
    for node in nodtab:
        fh.write(' {0:d}, '.format(node[0]))
        fh.write(', '.join('{0: .8f}'.format(float(x)) for x in node[1:]))
        fh.write('\n')

    fh.write('*Element, type=None, elset=EAll\n')
    for elem in eletab:
        elem = [elem[0]] + elem[2:]
        fh.write(' ' + ', '.join('{0:d}'.format(int(x)) for x in elem))
        fh.write('\n')

    fh.write('*Solid Section, elset=EAll, material=None\n')

    fh.write('*Step, name=Step-1\n*Static\n')

    if bcs:
        fh.write('*Boundary\n')
        for key in sorted(bcs.keys(), key=lambda x: x[0]):
            line = ' {0:d}'.format(key[0])
            dof = {'U': ', 1, 1', 'V': ', 2, 2'}[key[1]]
            line += dof + ', {0:f}'.format(bcs[key])
            fh.write(line + '\n')

    if cfs:
        fh.write('*CLoad\n')
        for key in sorted(cfs.keys(), key=lambda x: x[0]):
            line = ' {0:d}'.format(key[0])
            dof = {'U': ', X', 'V': ', Y'}[key[1]]
            line += dof + ', {0:f}'.format(cfs[key])
            fh.write(line + '\n')

    fh.write('*End Step\n')

    fh.close()

if __name__ == '__main__':
    import argparse
    p = argparse.ArgumentParser()
    p.add_argument('source')
    p.add_argument('-o')
    args = p.parse_args()
    ParseInput(args.source, output=args.o)
